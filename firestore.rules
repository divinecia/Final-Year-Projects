rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // Authentication helpers
    function isAuthenticated() {
      return request.auth != null && request.auth.uid != null;
    }

    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    function isWorker() {
      return isAuthenticated() && 
             exists(/databases/$(database)/documents/workers/$(request.auth.uid));
    }

    function isHousehold() {
      return isAuthenticated() && 
             exists(/databases/$(database)/documents/households/$(request.auth.uid));
    }

    function isAdmin() {
      return isAuthenticated() && 
             exists(/databases/$(database)/documents/admin/$(request.auth.uid));
    }

    // Allow initial admin creation for seeding - temporarily relaxed
    function isInitialAdmin() {
      return true; // Allow any request during seeding
    }

    // Validation helpers
    function isValidEmail(email) {
      return email is string && 
             email.size() > 0 && 
             email.size() <= 254 &&
             email.matches('^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$');
    }

    function isValidPhone(phone) {
      return phone is string && 
             phone.size() >= 7 && 
             phone.size() <= 20 &&
             phone.matches('^\\+?[0-9\\-\\(\\)\\s]{7,20}$');
    }

    function isValidString(str, minLen, maxLen) {
      return str is string && 
             str.size() >= minLen && 
             str.size() <= maxLen;
    }

    function isValidPrice(price) {
      return price is number && 
             price >= 0 && 
             price <= 1000000;
    }

    function isValidRating(rating) {
      return rating is number && 
             rating >= 1 && 
             rating <= 5 && 
             rating == int(rating);
    }

    function isValidLocation(location) {
      return location is map &&
             'province' in location &&
             'district' in location &&
             'municipality' in location &&
             'neighborhood' in location &&
             'street' in location &&
             'houseNumber' in location &&
             'postalCode' in location &&
             'city' in location &&
             'country' in location &&
             'fullAddress' in location &&
             location.province is string &&
             location.district is string &&
             location.municipality is string &&
             location.neighborhood is string &&
             location.street is string &&
             location.houseNumber is string &&
             location.postalCode is string &&
             location.city is string &&
             location.country is string &&
             location.fullAddress is string &&
             location.province.size() > 0 &&
             location.district.size() > 0 &&
             location.municipality.size() > 0 &&
             location.neighborhood.size() > 0 &&
             location.street.size() > 0 &&
             location.houseNumber.size() > 0 &&
             location.postalCode.size() > 0 &&
             location.city.size() > 0 &&
             location.country.size() > 0 &&
             location.fullAddress.size() > 0;
    }

    function isValidServices(services) {
      return services is list &&
             services.size() > 0 &&
             services.size() <= 20;
    }

    // Admin Collection - Allow initial admin creation
    match /admin/{adminId} {
      allow read: if isAuthenticated() && (isAdmin() || isInitialAdmin());
      allow create: if isInitialAdmin() || isAdmin();
      allow update: if isOwner(adminId) || isAdmin();
      allow delete: if isAdmin();
    }

    // Users Collection (for unified user lookup)
    match /users/{userId} {
      allow read: if isAuthenticated();
      allow create: if isOwner(userId) || isAdmin() || isInitialAdmin();
      allow update: if isOwner(userId) || isAdmin();
      allow delete: if isAdmin();

      function isValidUserData() {
        let data = request.resource.data;
        return data.keys().hasAll(['uid', 'email', 'role', 'isActive', 'emailVerified', 'createdAt']) &&
               data.uid == userId &&
               isValidEmail(data.email) &&
               data.role in ['admin', 'household', 'worker'] &&
               data.isActive is bool &&
               data.emailVerified is bool &&
               data.createdAt is timestamp &&
               (!('displayName' in data) || isValidString(data.displayName, 1, 100)) &&
               (!('phoneNumber' in data) || isValidPhone(data.phoneNumber)) &&
               (!('photoURL' in data) || isValidString(data.photoURL, 1, 500)) &&
               (!('lastLoginAt' in data) || data.lastLoginAt is timestamp) &&
               (!('updatedAt' in data) || data.updatedAt is timestamp);
      }
    }

    // Workers Collection
    match /workers/{workerId} {
      allow read: if isAuthenticated();
      allow create: if isOwner(workerId) && isValidWorkerData();
      allow update: if isOwner(workerId) && isValidWorkerUpdate();
      allow delete: if isOwner(workerId) || isAdmin();

      function isValidWorkerData() {
        let data = request.resource.data;
        return data.keys().hasAll(['fullName', 'email', 'phone', 'services', 'location', 'dateOfBirth', 'gender', 'status', 'createdAt']) &&
               isValidString(data.fullName, 2, 100) &&
               isValidEmail(data.email) &&
               isValidPhone(data.phone) &&
               isValidServices(data.services) &&
               isValidLocation(data.location) &&
               data.dateOfBirth is timestamp &&
               data.gender in ['male', 'female', 'other'] &&
               data.status in ['active', 'inactive', 'suspended', 'pending_verification'] &&
               data.createdAt is timestamp &&
               data.createdAt == request.time;
      }

      function isValidWorkerUpdate() {
        let data = request.resource.data;
        let existingData = resource.data;
        return data.keys().hasAll(['fullName', 'email', 'phone', 'services', 'location', 'dateOfBirth', 'gender', 'status', 'createdAt', 'updatedAt']) &&
               isValidString(data.fullName, 2, 100) &&
               isValidEmail(data.email) &&
               isValidPhone(data.phone) &&
               isValidServices(data.services) &&
               isValidLocation(data.location) &&
               data.dateOfBirth is timestamp &&
               data.gender in ['male', 'female', 'other'] &&
               data.status in ['active', 'inactive', 'suspended', 'pending_verification'] &&
               data.updatedAt is timestamp &&
               data.updatedAt == request.time &&
               data.createdAt == existingData.createdAt;
      }

      match /documents/{documentId} {
        allow read, write: if isOwner(workerId) || isAdmin();
      }

      match /availability/{availabilityId} {
        allow read: if isAuthenticated();
        allow write: if isOwner(workerId);
      }
    }

    // Households Collection
    match /households/{householdId} {
      allow read: if isAuthenticated();
      allow create: if isOwner(householdId) && isValidHouseholdData();
      allow update: if isOwner(householdId) && isValidHouseholdUpdate();
      allow delete: if isOwner(householdId) || isAdmin();

      function isValidHouseholdData() {
        let data = request.resource.data;
        return data.keys().hasAll(['fullName', 'email', 'phone', 'location', 'status', 'createdAt']) &&
               isValidString(data.fullName, 2, 100) &&
               isValidEmail(data.email) &&
               isValidPhone(data.phone) &&
               isValidLocation(data.location) &&
               data.status in ['active', 'inactive', 'suspended'] &&
               data.createdAt is timestamp &&
               data.createdAt == request.time;
      }

      function isValidHouseholdUpdate() {
        let data = request.resource.data;
        let existingData = resource.data;
        return data.keys().hasAll(['fullName', 'email', 'phone', 'location', 'status', 'createdAt', 'updatedAt']) &&
               isValidString(data.fullName, 2, 100) &&
               isValidEmail(data.email) &&
               isValidPhone(data.phone) &&
               isValidLocation(data.location) &&
               data.status in ['active', 'inactive', 'suspended'] &&
               data.updatedAt is timestamp &&
               data.updatedAt == request.time &&
               data.createdAt == existingData.createdAt;
      }
    }

    // Jobs Collection
    match /jobs/{jobId} {
      allow read: if isAuthenticated();
      allow create: if isHousehold() && isValidJobData();
      allow update: if canUpdateJob() && isValidJobUpdate();
      allow delete: if (isOwner(resource.data.householdId) || isAdmin()) && canDeleteJob();

      function isValidJobData() {
        let data = request.resource.data;
        return data.keys().hasAll(['title', 'description', 'serviceType', 'householdId', 'status', 'location', 'budget', 'createdAt']) &&
               isValidString(data.title, 5, 200) &&
               isValidString(data.description, 10, 2000) &&
               isValidString(data.serviceType, 2, 100) &&
               data.householdId == request.auth.uid &&
               data.status == 'open' &&
               isValidLocation(data.location) &&
               isValidPrice(data.budget) &&
               data.createdAt is timestamp &&
               data.createdAt == request.time;
      }

      function isValidJobUpdate() {
        let data = request.resource.data;
        let existingData = resource.data;
        return data.keys().hasAll(['title', 'description', 'serviceType', 'householdId', 'status', 'location', 'budget', 'createdAt', 'updatedAt']) &&
               isValidString(data.title, 5, 200) &&
               isValidString(data.description, 10, 2000) &&
               isValidString(data.serviceType, 2, 100) &&
               data.householdId == existingData.householdId &&
               data.status in ['open', 'in_progress', 'completed', 'cancelled'] &&
               isValidLocation(data.location) &&
               isValidPrice(data.budget) &&
               data.updatedAt is timestamp &&
               data.updatedAt == request.time &&
               data.createdAt == existingData.createdAt;
      }

      function canUpdateJob() {
        return isOwner(resource.data.householdId) || 
               (isWorker() && 'assignedWorkerId' in resource.data && resource.data.assignedWorkerId == request.auth.uid) ||
               isAdmin();
      }

      function canDeleteJob() {
        return resource.data.status in ['open', 'cancelled'] || isAdmin();
      }

      // Job applications subcollection
      match /applications/{applicationId} {
        allow read: if isAuthenticated() && (
          request.auth.uid == resource.data.workerId ||
          request.auth.uid == get(/databases/$(database)/documents/jobs/$(jobId)).data.householdId ||
          isAdmin()
        );
        allow create: if isWorker() && isValidJobApplication();
        allow update: if canUpdateJobApplication();
        allow delete: if isOwner(resource.data.workerId) || isAdmin();

        function isValidJobApplication() {
          let data = request.resource.data;
          return data.keys().hasAll(['workerId', 'jobId', 'status', 'proposedPrice', 'message', 'createdAt']) &&
                 data.workerId == request.auth.uid &&
                 data.jobId == jobId &&
                 data.status == 'pending' &&
                 isValidPrice(data.proposedPrice) &&
                 isValidString(data.message, 10, 1000) &&
                 data.createdAt is timestamp &&
                 data.createdAt == request.time;
        }

        function canUpdateJobApplication() {
          return isOwner(resource.data.workerId) || 
                 request.auth.uid == get(/databases/$(database)/documents/jobs/$(jobId)).data.householdId ||
                 isAdmin();
        }
      }
    }

    // Bookings Collection
    match /bookings/{bookingId} {
      allow read: if canAccessBooking();
      allow create: if isAuthenticated() && isValidBookingData();
      allow update: if canUpdateBooking() && isValidBookingUpdate();
      allow delete: if (isOwner(resource.data.householdId) || isAdmin()) && canDeleteBooking();

      function canAccessBooking() {
        return isAuthenticated() &&
               (request.auth.uid == resource.data.householdId ||
                request.auth.uid == resource.data.workerId ||
                isAdmin());
      }

      function isValidBookingData() {
        let data = request.resource.data;
        return data.keys().hasAll(['jobId', 'householdId', 'workerId', 'status', 'scheduledDate', 'estimatedPrice', 'createdAt']) &&
               isValidString(data.jobId, 1, 100) &&
               isValidString(data.householdId, 1, 100) &&
               isValidString(data.workerId, 1, 100) &&
               data.status == 'pending' &&
               data.scheduledDate is timestamp &&
               data.scheduledDate > request.time &&
               isValidPrice(data.estimatedPrice) &&
               data.createdAt is timestamp &&
               data.createdAt == request.time &&
               (request.auth.uid == data.householdId || request.auth.uid == data.workerId);
      }

      function isValidBookingUpdate() {
        let data = request.resource.data;
        let existingData = resource.data;
        return data.keys().hasAll(['jobId', 'householdId', 'workerId', 'status', 'scheduledDate', 'estimatedPrice', 'createdAt', 'updatedAt']) &&
               data.jobId == existingData.jobId &&
               data.householdId == existingData.householdId &&
               data.workerId == existingData.workerId &&
               data.status in ['pending', 'confirmed', 'in_progress', 'completed', 'cancelled'] &&
               data.scheduledDate is timestamp &&
               isValidPrice(data.estimatedPrice) &&
               data.updatedAt is timestamp &&
               data.updatedAt == request.time &&
               data.createdAt == existingData.createdAt;
      }

      function canUpdateBooking() {
        return isOwner(resource.data.householdId) ||
               isOwner(resource.data.workerId) ||
               isAdmin();
      }

      function canDeleteBooking() {
        return resource.data.status in ['pending', 'cancelled'] || isAdmin();
      }
    }

    // Reviews Collection
    match /reviews/{reviewId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && isValidReviewData();
      allow update: if isOwner(resource.data.householdId) && isValidReviewUpdate();
      allow delete: if isOwner(resource.data.householdId) || isAdmin();

      function isValidReviewData() {
        let data = request.resource.data;
        return data.keys().hasAll(['householdId', 'workerId', 'rating', 'comment', 'createdAt']) &&
               data.householdId == request.auth.uid &&
               isValidString(data.workerId, 1, 100) &&
               isValidRating(data.rating) &&
               isValidString(data.comment, 5, 2000) &&
               data.createdAt is timestamp &&
               data.createdAt == request.time &&
               (!('bookingId' in data) || isValidString(data.bookingId, 1, 100)) &&
               (!('serviceId' in data) || isValidString(data.serviceId, 1, 100)) &&
               (!('reviewType' in data) || data.reviewType in ['household_to_worker', 'worker_to_household']) &&
               (!('isVerified' in data) || data.isVerified is bool) &&
               (!('workerName' in data) || isValidString(data.workerName, 1, 100)) &&
               (!('jobTitle' in data) || isValidString(data.jobTitle, 1, 200));
      }

      function isValidReviewUpdate() {
        let data = request.resource.data;
        let existingData = resource.data;
        return data.householdId == existingData.householdId &&
               data.workerId == existingData.workerId &&
               isValidRating(data.rating) &&
               isValidString(data.comment, 5, 2000) &&
               data.createdAt == existingData.createdAt &&
               (!('updatedAt' in data) || data.updatedAt is timestamp) &&
               (!('isVerified' in data) || data.isVerified is bool);
      }
               isValidString(data.comment, 5, 2000) &&
               data.createdAt == existingData.createdAt &&
               data.updatedAt is timestamp &&
               data.updatedAt == request.time;
      }
    }

    // Chats Collection
    match /chats/{chatId} {
      allow read: if canAccessChat();
      allow create: if isAuthenticated() && isValidChatData();
      allow update: if canAccessChat() && isValidChatUpdate();
      allow delete: if isAdmin();

      function canAccessChat() {
        return isAuthenticated() &&
               (request.auth.uid in resource.data.participants || isAdmin());
      }

      function isValidChatData() {
        let data = request.resource.data;
        return data.keys().hasAll(['participants', 'createdAt']) &&
               data.participants is list &&
               data.participants.size() == 2 &&
               request.auth.uid in data.participants &&
               data.createdAt is timestamp &&
               data.createdAt == request.time;
      }

      function isValidChatUpdate() {
        let data = request.resource.data;
        let existingData = resource.data;
        return data.participants == existingData.participants &&
               data.updatedAt is timestamp &&
               data.updatedAt == request.time &&
               data.createdAt == existingData.createdAt;
      }

      // Messages subcollection
      match /messages/{messageId} {
        allow read: if canAccessChat();
        allow create: if canAccessChat() && isValidMessageData();
        allow update: if canAccessChat() && isValidMessageUpdate();
        allow delete: if isAdmin();

        function isValidMessageData() {
          let data = request.resource.data;
          return data.keys().hasAll(['text', 'senderId', 'senderName', 'senderType', 'timestamp', 'isRead']) &&
                 isValidString(data.text, 1, 5000) &&
                 data.senderId == request.auth.uid &&
                 isValidString(data.senderName, 1, 100) &&
                 data.senderType in ['household', 'worker', 'admin'] &&
                 data.timestamp == request.time &&
                 data.isRead == false;
        }

        function isValidMessageUpdate() {
          let data = request.resource.data;
          let existingData = resource.data;
          return data.text == existingData.text &&
                 data.senderId == existingData.senderId &&
                 data.timestamp == existingData.timestamp;
        }
      }
    }

    // Notifications Collection
    match /notifications/{notificationId} {
      allow read: if canAccessNotification();
      allow create: if isAuthenticated() && isValidNotificationData();
      allow update: if canAccessNotification() && isValidNotificationUpdate();
      allow delete: if isOwner(resource.data.userId) || isAdmin();

      function canAccessNotification() {
        return isAuthenticated() &&
               (request.auth.uid == resource.data.userId || isAdmin());
      }

      function isValidNotificationData() {
        let data = request.resource.data;
        return data.keys().hasAll(['userId', 'title', 'message', 'type', 'isRead', 'createdAt']) &&
               isValidString(data.title, 1, 200) &&
               isValidString(data.message, 1, 1000) &&
               data.type in ['booking', 'payment', 'job', 'system', 'reminder'] &&
               data.isRead == false &&
               data.createdAt is timestamp &&
               data.createdAt == request.time;
      }

      function isValidNotificationUpdate() {
        let data = request.resource.data;
        let existingData = resource.data;
        return data.userId == existingData.userId &&
               data.title == existingData.title &&
               data.message == existingData.message &&
               data.type == existingData.type &&
               data.createdAt == existingData.createdAt;
      }
    }

    // Service Payments Collection
    match /servicePayments/{paymentId} {
      allow read: if canAccessServicePayment();
      allow create: if isAuthenticated() && isValidServicePaymentData();
      allow update: if canAccessServicePayment() && isValidServicePaymentUpdate();
      allow delete: if isAdmin();

      function canAccessServicePayment() {
        return isAuthenticated() &&
               (request.auth.uid == resource.data.householdId || 
                request.auth.uid == resource.data.workerId || 
                isAdmin());
      }

      function isValidServicePaymentData() {
        let data = request.resource.data;
        return data.keys().hasAll(['householdId', 'workerId', 'amount', 'status', 'createdAt']) &&
               data.householdId is string &&
               data.workerId is string &&
               isValidPrice(data.amount) &&
               data.status in ['pending', 'completed', 'failed'] &&
               data.createdAt is timestamp &&
               data.createdAt == request.time &&
               (!('paymentMethod' in data) || data.paymentMethod in ['mobile_money', 'card', 'bank_transfer']) &&
               (!('serviceType' in data) || isValidString(data.serviceType, 1, 100)) &&
               (!('workerName' in data) || isValidString(data.workerName, 1, 100)) &&
               (!('householdName' in data) || isValidString(data.householdName, 1, 100));
      }

      function isValidServicePaymentUpdate() {
        let data = request.resource.data;
        let existingData = resource.data;
        // Only allow status, updatedAt, and transaction details updates
        return data.householdId == existingData.householdId &&
               data.workerId == existingData.workerId &&
               data.amount == existingData.amount &&
               data.createdAt == existingData.createdAt &&
               (!('updatedAt' in data) || data.updatedAt is timestamp);
      }
    }

    // Training Payments Collection
    match /trainingPayments/{paymentId} {
      allow read: if canAccessTrainingPayment();
      allow create: if isAuthenticated() && isValidTrainingPaymentData();
      allow update: if canAccessTrainingPayment() && isValidTrainingPaymentUpdate();
      allow delete: if isAdmin();

      function canAccessTrainingPayment() {
        return isAuthenticated() &&
               (request.auth.uid == resource.data.workerId || isAdmin());
      }

      function isValidTrainingPaymentData() {
        let data = request.resource.data;
        return data.keys().hasAll(['workerId', 'amount', 'status', 'createdAt']) &&
               data.workerId is string &&
               isValidPrice(data.amount) &&
               data.status in ['pending', 'completed', 'failed'] &&
               data.createdAt is timestamp &&
               data.createdAt == request.time &&
               (!('paymentMethod' in data) || data.paymentMethod in ['mobile_money', 'card', 'bank_transfer']) &&
               (!('courseTitle' in data) || isValidString(data.courseTitle, 1, 200)) &&
               (!('workerName' in data) || isValidString(data.workerName, 1, 100));
      }

      function isValidTrainingPaymentUpdate() {
        let data = request.resource.data;
        let existingData = resource.data;
        // Only allow status, updatedAt, and transaction details updates
        return data.workerId == existingData.workerId &&
               data.amount == existingData.amount &&
               data.createdAt == existingData.createdAt &&
               (!('updatedAt' in data) || data.updatedAt is timestamp);
      }
    }

    // Services Collection
    match /services/{serviceId} {
      allow read: if isAuthenticated();
      allow create, update: if isAdmin() && isValidServiceData();
      allow delete: if isAdmin();

      function isValidServiceData() {
        let data = request.resource.data;
        return data.keys().hasAll(['name', 'category', 'description', 'basePrice', 'priceUnit', 'estimatedDuration', 'isActive']) &&
               isValidString(data.name, 1, 100) &&
               data.category in ['cleaning', 'cooking', 'gardening', 'childcare', 'eldercare', 'petcare', 'maintenance', 'laundry', 'other'] &&
               isValidString(data.description, 10, 500) &&
               isValidPrice(data.basePrice) &&
               data.priceUnit in ['hourly', 'daily', 'weekly', 'monthly', 'per_job'] &&
               data.estimatedDuration is number &&
               data.estimatedDuration >= 30 &&
               data.estimatedDuration <= 1440 &&
               data.isActive is bool &&
               (!('icon' in data) || isValidString(data.icon, 1, 10)) &&
               (!('requirements' in data) || (data.requirements is list && data.requirements.size() <= 10)) &&
               (!('createdAt' in data) || data.createdAt is timestamp) &&
               (!('updatedAt' in data) || data.updatedAt is timestamp);
      }
    }

    // Locations Collection
    match /locations/{locationId} {
      allow read: if isAuthenticated();
      allow write: if isAdmin();
    }

    // System Configuration Collection  
    match /system/{configId} {
      allow read: if isAuthenticated();
      allow write: if isAdmin();
    }

    // Admin Logs Collection
    match /adminLogs/{logId} {
      allow read, write: if isAdmin();
    }

    // Reports Collection
    match /reports/{reportId} {
      allow read: if isAdmin();
      allow create: if isAuthenticated() && isValidReportData();
      allow update: if isAdmin();
      allow delete: if isAdmin();

      function isValidReportData() {
        let data = request.resource.data;
        return data.keys().hasAll(['userId', 'title', 'description', 'type', 'status', 'createdAt']) &&
               data.userId == request.auth.uid &&
               isValidString(data.title, 1, 200) &&
               isValidString(data.description, 1, 2000) &&
               data.type in ['bug', 'feature', 'complaint', 'security', 'other'] &&
               data.status == 'pending' &&
               data.createdAt is timestamp &&
               data.createdAt == request.time;
      }
    }

    // Locations Collection
    match /locations/{locationId} {
      allow read: if isAuthenticated();
      allow write: if isAdmin();
    }

    // System Collection
    match /system/{configId} {
      allow read: if isAuthenticated();
      allow write: if isAdmin();
    }

    // System Collections
    match /analytics/{document=**} {
      allow read, write: if isAdmin();
    }

    match /config/{document=**} {
      allow read: if isAuthenticated();
      allow write: if isAdmin();
    }

    match /metadata/{document=**} {
      allow read: if isAuthenticated();
      allow write: if isAdmin();
    }

    // Default deny rule
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
}

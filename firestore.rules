rules_version = '2';/** * Comprehensive Firestore Security Rules for HouseHelp Application * Ensures robust data security, proper authentication, and role-based access control * Covers all collections with proper validation and edge case handling */service cloud.firestore {  match /databases/{database}/documents {    // ===== HELPER FUNCTIONS =====        // Authentication helpers    function isAuthenticated() {      return request.auth != null && request.auth.uid != null;    }    function isOwner(userId) {      return isAuthenticated() && request.auth.uid == userId;    }    function isWorker() {      return isAuthenticated() &&              exists(/databases/$(database)/documents/workers/$(request.auth.uid));    }    function isHousehold() {      return isAuthenticated() &&              exists(/databases/$(database)/documents/households/$(request.auth.uid));    }    function isAdmin() {      return isAuthenticated() &&              exists(/databases/$(database)/documents/admin/$(request.auth.uid));    }    function getUserRole() {      return isAdmin() ? 'admin' :              isWorker() ? 'worker' :              isHousehold() ? 'household' :              'none';    }    // Conversation helpers    function isParticipantInConversation(conversationData) {      return isAuthenticated() &&              'participants' in conversationData &&              conversationData.participants is list &&             request.auth.uid in conversationData.participants;    }    function canAccessConversation(conversationId) {      return exists(/databases/$(database)/documents/conversations/$(conversationId)) &&             isParticipantInConversation(get(/databases/$(database)/documents/conversations/$(conversationId)).data);    }    // Validation helpers    function isValidTimestamp(ts) {      return ts is timestamp;    }    function isValidEmail(email) {      return email is string &&              email.size() > 0 &&              email.size() <= 254 &&             email.matches('^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$');    }    function isValidPhone(phone) {      return phone is string &&              phone.size() >= 7 &&              phone.size() <= 20 &&             phone.matches('^\\+?[0-9\\-\\(\\)\\s]{7,20}$');    }    function isValidString(str, minLen, maxLen) {      return str is string &&              str.size() >= minLen &&              str.size() <= maxLen;    }    function isValidNumber(num, minVal, maxVal) {      return num is number &&              num >= minVal &&              num <= maxVal;    }    function isValidPrice(price) {      return price is number &&              price >= 0 &&              price <= 1000000; // Max price of 1M RWF    }    function isValidRating(rating) {      return rating is number &&              rating >= 1 &&              rating <= 5 &&              rating == int(rating); // Must be integer    }    function isValidStatus(status, allowedStatuses) {      return status is string &&              status in allowedStatuses;    }    // Location validation    function isValidLocation(location) {      return location is map &&             'district' in location &&             'sector' in location &&             'cell' in location &&             location.district is string &&             location.sector is string &&             location.cell is string &&             location.district.size() > 0 &&             location.sector.size() > 0 &&             location.cell.size() > 0;    }    // Service validation    function isValidServices(services) {      return services is list &&             services.size() > 0 &&             services.size() <= 20; // Max 20 services per worker    }    // ===== COLLECTION RULES =====    // --- Workers Collection ---    match /workers/{workerId} {      allow read: if isAuthenticated();      allow create: if isOwner(workerId) && isValidWorkerData() && !exists(/databases/$(database)/documents/workers/$(workerId));      allow update: if isOwner(workerId) && isValidWorkerUpdate();      allow delete: if (isOwner(workerId) || isAdmin()) && canDeleteWorker();      function isValidWorkerData() {        let data = request.resource.data;        return data.keys().hasAll(['fullName', 'email', 'phone', 'services', 'location', 'dateOfBirth', 'gender', 'status', 'createdAt']) &&               isValidString(data.fullName, 2, 100) &&               isValidEmail(data.email) &&               isValidPhone(data.phone) &&               isValidServices(data.services) &&               isValidLocation(data.location) &&               isValidTimestamp(data.dateOfBirth) &&               data.gender in ['male', 'female', 'other'] &&               data.status in ['active', 'inactive', 'suspended', 'pending_verification'] &&               isValidTimestamp(data.createdAt) &&               data.createdAt == request.time &&               // Optional fields validation               (!('bio' in data) || isValidString(data.bio, 0, 1000)) &&               (!('experience' in data) || (data.experience is number && data.experience >= 0 && data.experience <= 50)) &&               (!('rating' in data) || (data.rating is number && data.rating >= 0 && data.rating <= 5)) &&               (!('totalReviews' in data) || (data.totalReviews is number && data.totalReviews >= 0)) &&               (!('isVerified' in data) || data.isVerified is bool) &&               (!('languages' in data) || (data.languages is list && data.languages.size() <= 10)) &&               (!('availability' in data) || data.availability is map) &&               (!('profilePictureUrl' in data) || isValidString(data.profilePictureUrl, 0, 500)) &&               (!('documentsUploaded' in data) || data.documentsUploaded is bool);      }      function isValidWorkerUpdate() {        let data = request.resource.data;        let existingData = resource.data;        return data.keys().hasAll(['fullName', 'email', 'phone', 'services', 'location', 'dateOfBirth', 'gender', 'status', 'createdAt', 'updatedAt']) &&               isValidString(data.fullName, 2, 100) &&               isValidEmail(data.email) &&               isValidPhone(data.phone) &&               isValidServices(data.services) &&               isValidLocation(data.location) &&               isValidTimestamp(data.dateOfBirth) &&               data.gender in ['male', 'female', 'other'] &&               data.status in ['active', 'inactive', 'suspended', 'pending_verification'] &&               isValidTimestamp(data.updatedAt) &&               data.updatedAt == request.time &&               data.createdAt == existingData.createdAt && // Cannot change creation time               // Status change restrictions               (isAdmin() || (data.status != 'suspended' && existingData.status != 'suspended'));      }      function canDeleteWorker() {        return !exists(/databases/$(database)/documents/bookings) ||                !existsAfterCurrentDocument(/databases/$(database)/documents/bookings) ||               isAdmin();      }      // Worker subcollections      match /documents/{documentId} {        allow read, write: if isOwner(workerId) || isAdmin();      }      match /availability/{availabilityId} {        allow read: if isAuthenticated();        allow write: if isOwner(workerId);      }    }    // --- Households Collection ---    match /households/{householdId} {      allow read: if isAuthenticated();      allow create: if isOwner(householdId) && isValidHouseholdData() && !exists(/databases/$(database)/documents/households/$(householdId));      allow update: if isOwner(householdId) && isValidHouseholdUpdate();      allow delete: if (isOwner(householdId) || isAdmin()) && canDeleteHousehold();      function isValidHouseholdData() {        let data = request.resource.data;        return data.keys().hasAll(['fullName', 'email', 'phone', 'location', 'status', 'createdAt']) &&               isValidString(data.fullName, 2, 100) &&               isValidEmail(data.email) &&               isValidPhone(data.phone) &&               isValidLocation(data.location) &&               data.status in ['active', 'inactive', 'suspended'] &&               isValidTimestamp(data.createdAt) &&               data.createdAt == request.time &&               // Optional fields validation               (!('profilePictureUrl' in data) || isValidString(data.profilePictureUrl, 0, 500)) &&               (!('householdSize' in data) || (data.householdSize is number && data.householdSize >= 1 && data.householdSize <= 50)) &&               (!('preferredLanguage' in data) || isValidString(data.preferredLanguage, 2, 10)) &&               (!('isVerified' in data) || data.isVerified is bool);      }      function isValidHouseholdUpdate() {        let data = request.resource.data;        let existingData = resource.data;        return data.keys().hasAll(['fullName', 'email', 'phone', 'location', 'status', 'createdAt', 'updatedAt']) &&               isValidString(data.fullName, 2, 100) &&               isValidEmail(data.email) &&               isValidPhone(data.phone) &&               isValidLocation(data.location) &&               data.status in ['active', 'inactive', 'suspended'] &&               isValidTimestamp(data.updatedAt) &&               data.updatedAt == request.time &&
               data.createdAt == existingData.createdAt &&
               // Status change restrictions
               (isAdmin() || (data.status != 'suspended' && existingData.status != 'suspended'));
      }

      function canDeleteHousehold() {
        return !exists(/databases/$(database)/documents/jobs) || 
               !existsAfterCurrentDocument(/databases/$(database)/documents/jobs) ||
               isAdmin();
      }
    }

    // --- Admin Collection ---
    match /admin/{adminId} {
      allow read: if isAuthenticated() && (request.auth.uid == adminId || isAdmin());
      allow create: if isAuthenticated() && isOwner(adminId) && isValidAdminData();
      allow update: if isOwner(adminId) && isValidAdminUpdate();
      allow delete: if false; // Admins cannot be deleted via client

      function isValidAdminData() {
        let data = request.resource.data;
        return data.keys().hasAll(['fullName', 'email', 'role', 'status', 'createdAt']) &&
               isValidString(data.fullName, 2, 100) &&
               isValidEmail(data.email) &&
               data.role in ['super_admin', 'admin', 'moderator'] &&
               data.status in ['active', 'inactive'] &&
               isValidTimestamp(data.createdAt) &&
               data.createdAt == request.time;
      }

      function isValidAdminUpdate() {
        let data = request.resource.data;
        let existingData = resource.data;
        return data.keys().hasAll(['fullName', 'email', 'role', 'status', 'createdAt', 'updatedAt']) &&
               isValidString(data.fullName, 2, 100) &&
               isValidEmail(data.email) &&
               data.role in ['super_admin', 'admin', 'moderator'] &&
               data.status in ['active', 'inactive'] &&
               isValidTimestamp(data.updatedAt) &&
               data.updatedAt == request.time &&
               data.createdAt == existingData.createdAt &&
               // Only super_admin can change roles
               (data.role == existingData.role || (existingData.role == 'super_admin'));
      }
    }

    // --- Jobs Collection ---
    match /jobs/{jobId} {
      allow read: if isAuthenticated();
      allow create: if isHousehold() && isValidJobData();
      allow update: if canUpdateJob() && isValidJobUpdate();
      allow delete: if (isOwner(resource.data.householdId) || isAdmin()) && canDeleteJob();

      function isValidJobData() {
        let data = request.resource.data;
        return data.keys().hasAll(['title', 'description', 'serviceType', 'householdId', 'status', 'location', 'budget', 'createdAt']) &&
               isValidString(data.title, 5, 200) &&
               isValidString(data.description, 10, 2000) &&
               isValidString(data.serviceType, 2, 100) &&
               data.householdId == request.auth.uid &&
               data.status == 'open' &&
               isValidLocation(data.location) &&
               isValidPrice(data.budget) &&
               isValidTimestamp(data.createdAt) &&
               data.createdAt == request.time &&
               // Optional fields validation
               (!('scheduledDate' in data) || isValidTimestamp(data.scheduledDate)) &&
               (!('duration' in data) || (data.duration is number && data.duration > 0 && data.duration <= 24)) &&
               (!('urgency' in data) || data.urgency in ['low', 'medium', 'high']) &&
               (!('requirements' in data) || (data.requirements is list && data.requirements.size() <= 20)) &&
               (!('applicants' in data) || (data.applicants is list && data.applicants.size() == 0));
      }

      function isValidJobUpdate() {
        let data = request.resource.data;
        let existingData = resource.data;
        return data.keys().hasAll(['title', 'description', 'serviceType', 'householdId', 'status', 'location', 'budget', 'createdAt', 'updatedAt']) &&
               isValidString(data.title, 5, 200) &&
               isValidString(data.description, 10, 2000) &&
               isValidString(data.serviceType, 2, 100) &&
               data.householdId == existingData.householdId &&
               isValidStatus(data.status, ['open', 'in_progress', 'completed', 'cancelled']) &&
               isValidLocation(data.location) &&
               isValidPrice(data.budget) &&
               isValidTimestamp(data.updatedAt) &&
               data.updatedAt == request.time &&
               data.createdAt == existingData.createdAt &&
               // Status transition validation
               isValidStatusTransition(existingData.status, data.status) &&
               // Worker assignment validation
               (!('assignedWorkerId' in data) || (data.assignedWorkerId is string && isWorker()));
      }

      function canUpdateJob() {
        let data = request.resource.data;
        return isOwner(resource.data.householdId) || 
               (isWorker() && 'assignedWorkerId' in data && data.assignedWorkerId == request.auth.uid) ||
               isAdmin();
      }

      function canDeleteJob() {
        return resource.data.status in ['open', 'cancelled'] || isAdmin();
      }

      function isValidStatusTransition(oldStatus, newStatus) {
        return (oldStatus == 'open' && newStatus in ['in_progress', 'cancelled']) ||
               (oldStatus == 'in_progress' && newStatus in ['completed', 'cancelled']) ||
               (oldStatus == 'completed' && newStatus == 'completed') ||
               (oldStatus == 'cancelled' && newStatus == 'cancelled') ||
               isAdmin();
      }

      // Job applications subcollection
      match /applications/{applicationId} {
        allow read: if isAuthenticated() && (
          request.auth.uid == resource.data.workerId ||
          request.auth.uid == get(/databases/$(database)/documents/jobs/$(jobId)).data.householdId ||
          isAdmin()
        );
        allow create: if isWorker() && isValidJobApplication();
        allow update: if canUpdateJobApplication();
        allow delete: if isOwner(resource.data.workerId) || isAdmin();

        function isValidJobApplication() {
          let data = request.resource.data;
          return data.keys().hasAll(['workerId', 'jobId', 'status', 'proposedPrice', 'message', 'createdAt']) &&
                 data.workerId == request.auth.uid &&
                 data.jobId == jobId &&
                 data.status == 'pending' &&
                 isValidPrice(data.proposedPrice) &&
                 isValidString(data.message, 10, 1000) &&
                 isValidTimestamp(data.createdAt) &&
                 data.createdAt == request.time;
        }

        function canUpdateJobApplication() {
          return isOwner(resource.data.workerId) || 
                 request.auth.uid == get(/databases/$(database)/documents/jobs/$(jobId)).data.householdId ||
                 isAdmin();
        }
      }
    }

    // --- Bookings Collection ---
    match /bookings/{bookingId} {
      allow read: if canAccessBooking();
      allow create: if isAuthenticated() && isValidBookingData();
      allow update: if canUpdateBooking() && isValidBookingUpdate();
      allow delete: if (isOwner(resource.data.householdId) || isAdmin()) && canDeleteBooking();

      function canAccessBooking() {
        return isAuthenticated() &&
               (request.auth.uid == resource.data.householdId ||
                request.auth.uid == resource.data.workerId ||
                isAdmin());
      }

      function isValidBookingData() {
        let data = request.resource.data;
        return data.keys().hasAll(['jobId', 'householdId', 'workerId', 'status', 'scheduledDate', 'estimatedPrice', 'createdAt']) &&
               isValidString(data.jobId, 1, 100) &&
               isValidString(data.householdId, 1, 100) &&
               isValidString(data.workerId, 1, 100) &&
               data.status == 'pending' &&
               isValidTimestamp(data.scheduledDate) &&
               data.scheduledDate > request.time &&
               isValidPrice(data.estimatedPrice) &&
               isValidTimestamp(data.createdAt) &&
               data.createdAt == request.time &&
               // Verify the user is authorized to create this booking
               (request.auth.uid == data.householdId || request.auth.uid == data.workerId);
      }

      function isValidBookingUpdate() {
        let data = request.resource.data;
        let existingData = resource.data;
        return data.keys().hasAll(['jobId', 'householdId', 'workerId', 'status', 'scheduledDate', 'estimatedPrice', 'createdAt', 'updatedAt']) &&
               data.jobId == existingData.jobId &&
               data.householdId == existingData.householdId &&
               data.workerId == existingData.workerId &&
               isValidStatus(data.status, ['pending', 'confirmed', 'in_progress', 'completed', 'cancelled']) &&
               isValidTimestamp(data.scheduledDate) &&
               isValidPrice(data.estimatedPrice) &&
               isValidTimestamp(data.updatedAt) &&
               data.updatedAt == request.time &&
               data.createdAt == existingData.createdAt &&
               isValidBookingStatusTransition(existingData.status, data.status);
      }

      function canUpdateBooking() {
        return isOwner(resource.data.householdId) ||
               isOwner(resource.data.workerId) ||
               isAdmin();
      }

      function canDeleteBooking() {
        return resource.data.status in ['pending', 'cancelled'] || isAdmin();
      }

      function isValidBookingStatusTransition(oldStatus, newStatus) {
        return (oldStatus == 'pending' && newStatus in ['confirmed', 'cancelled']) ||
               (oldStatus == 'confirmed' && newStatus in ['in_progress', 'cancelled']) ||
               (oldStatus == 'in_progress' && newStatus in ['completed', 'cancelled']) ||
               (oldStatus == 'completed' && newStatus == 'completed') ||
               (oldStatus == 'cancelled' && newStatus == 'cancelled') ||
               isAdmin();
      }
    }

    // --- Conversations Collection ---
    match /conversations/{conversationId} {
      allow read: if isAuthenticated() && isParticipantInConversation(resource.data);
      allow create: if isAuthenticated() && isValidConversationData();
      allow update: if isAuthenticated() && isParticipantInConversation(resource.data) && isValidConversationUpdate();
      allow delete: if isAdmin();

      function isValidConversationData() {
        let data = request.resource.data;
        return data.keys().hasAll(['participants', 'createdAt', 'lastMessageAt']) &&
               data.participants is list &&
               data.participants.size() == 2 &&
               request.auth.uid in data.participants &&
               isValidTimestamp(data.createdAt) &&
               data.createdAt == request.time &&
               isValidTimestamp(data.lastMessageAt) &&
               // Verify both participants exist and are different roles
               data.participants[0] != data.participants[1];
      }

      function isValidConversationUpdate() {
        let data = request.resource.data;
        let existingData = resource.data;
        return data.keys().hasAll(['participants', 'createdAt', 'lastMessageAt', 'updatedAt']) &&
               data.participants == existingData.participants &&
               data.createdAt == existingData.createdAt &&
               isValidTimestamp(data.lastMessageAt) &&
               isValidTimestamp(data.updatedAt) &&
               data.updatedAt == request.time;
      }
    }

    // --- Messages Collection ---
    match /messages/{messageId} {
      allow read: if isAuthenticated() && canAccessMessage();
      allow create: if isAuthenticated() && isValidMessageData();
      allow update: if isOwner(resource.data.senderId) && isValidMessageUpdate();
      allow delete: if isOwner(resource.data.senderId) || isAdmin();

      function canAccessMessage() {
        return 'conversationId' in resource.data &&
               canAccessConversation(resource.data.conversationId);
      }

      function isValidMessageData() {
        let data = request.resource.data;
        return data.keys().hasAll(['conversationId', 'senderId', 'content', 'timestamp', 'type']) &&
               isValidString(data.conversationId, 1, 100) &&
               data.senderId == request.auth.uid &&
               isValidString(data.content, 1, 5000) &&
               isValidTimestamp(data.timestamp) &&
               data.timestamp == request.time &&
               data.type in ['text', 'image', 'document'] &&
               canAccessConversation(data.conversationId) &&
               (!('readBy' in data) || (data.readBy is list && data.readBy.size() <= 2)) &&
               (!('attachmentUrl' in data) || isValidString(data.attachmentUrl, 0, 500));
      }

      function isValidMessageUpdate() {
        let data = request.resource.data;
        let existingData = resource.data;
        return data.keys().hasAll(['conversationId', 'senderId', 'content', 'timestamp', 'type', 'updatedAt']) &&
               data.conversationId == existingData.conversationId &&
               data.senderId == existingData.senderId &&
               isValidString(data.content, 1, 5000) &&
               data.timestamp == existingData.timestamp &&
               data.type == existingData.type &&
               isValidTimestamp(data.updatedAt) &&
               data.updatedAt == request.time;
      }
    }

    // --- Reviews Collection ---
    match /reviews/{reviewId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && isValidReviewData();
      allow update: if isOwner(resource.data.householdId) && isValidReviewUpdate();
      allow delete: if isOwner(resource.data.householdId) || isAdmin();

      function isValidReviewData() {
        let data = request.resource.data;
        return data.keys().hasAll(['bookingId', 'householdId', 'workerId', 'rating', 'comment', 'createdAt']) &&
               isValidString(data.bookingId, 1, 100) &&
               data.householdId == request.auth.uid &&
               isValidString(data.workerId, 1, 100) &&
               isValidRating(data.rating) &&
               isValidString(data.comment, 5, 2000) &&
               isValidTimestamp(data.createdAt) &&
               data.createdAt == request.time &&
               // Verify booking exists and is completed
               exists(/databases/$(database)/documents/bookings/$(data.bookingId)) &&
               get(/databases/$(database)/documents/bookings/$(data.bookingId)).data.status == 'completed' &&
               get(/databases/$(database)/documents/bookings/$(data.bookingId)).data.householdId == request.auth.uid;
      }

      function isValidReviewUpdate() {
        let data = request.resource.data;
        let existingData = resource.data;
        return data.keys().hasAll(['bookingId', 'householdId', 'workerId', 'rating', 'comment', 'createdAt', 'updatedAt']) &&
               data.bookingId == existingData.bookingId &&
               data.householdId == existingData.householdId &&
               data.workerId == existingData.workerId &&
               isValidRating(data.rating) &&
               isValidString(data.comment, 5, 2000) &&
               data.createdAt == existingData.createdAt &&
               isValidTimestamp(data.updatedAt) &&
               data.updatedAt == request.time;
      }
    }

    // --- Payments Collection ---
    match /payments/{paymentId} {
      allow read: if canAccessPayment();
      allow create: if isAuthenticated() && isValidPaymentData();
      allow update: if canUpdatePayment() && isValidPaymentUpdate();
      allow delete: if isAdmin();

      function canAccessPayment() {
        return isAuthenticated() &&
               (request.auth.uid == resource.data.householdId ||
                request.auth.uid == resource.data.workerId ||
                isAdmin());
      }

      function isValidPaymentData() {
        let data = request.resource.data;
        return data.keys().hasAll(['bookingId', 'householdId', 'workerId', 'amount', 'status', 'paymentMethod', 'createdAt']) &&
               isValidString(data.bookingId, 1, 100) &&
               isValidString(data.householdId, 1, 100) &&
               isValidString(data.workerId, 1, 100) &&
               isValidPrice(data.amount) &&
               data.status == 'pending' &&
               data.paymentMethod in ['cash', 'mobile_money', 'bank_transfer', 'card'] &&
               isValidTimestamp(data.createdAt) &&
               data.createdAt == request.time &&
               // Verify booking exists and user is authorized
               exists(/databases/$(database)/documents/bookings/$(data.bookingId)) &&
               (request.auth.uid == data.householdId || request.auth.uid == data.workerId);
      }

      function isValidPaymentUpdate() {
        let data = request.resource.data;
        let existingData = resource.data;
        return data.keys().hasAll(['bookingId', 'householdId', 'workerId', 'amount', 'status', 'paymentMethod', 'createdAt', 'updatedAt']) &&
               data.bookingId == existingData.bookingId &&
               data.householdId == existingData.householdId &&
               data.workerId == existingData.workerId &&
               data.amount == existingData.amount &&
               isValidStatus(data.status, ['pending', 'processing', 'completed', 'failed', 'refunded']) &&
               data.paymentMethod == existingData.paymentMethod &&
               data.createdAt == existingData.createdAt &&
               isValidTimestamp(data.updatedAt) &&
               data.updatedAt == request.time &&
               isValidPaymentStatusTransition(existingData.status, data.status);
      }

      function canUpdatePayment() {
        return isOwner(resource.data.householdId) ||
               isOwner(resource.data.workerId) ||
               isAdmin();
      }

      function isValidPaymentStatusTransition(oldStatus, newStatus) {
        return (oldStatus == 'pending' && newStatus in ['processing', 'failed']) ||
               (oldStatus == 'processing' && newStatus in ['completed', 'failed']) ||
               (oldStatus == 'completed' && newStatus in ['completed', 'refunded']) ||
               (oldStatus == 'failed' && newStatus == 'failed') ||
               (oldStatus == 'refunded' && newStatus == 'refunded') ||
               isAdmin();
      }
    }

    // --- Notifications Collection ---
    match /notifications/{notificationId} {
      allow read: if isOwner(resource.data.userId);
      allow create: if isValidNotificationCreation() && isValidNotificationData();
      allow update: if isOwner(resource.data.userId) && isValidNotificationUpdate();
      allow delete: if isOwner(resource.data.userId) || isAdmin();

      function isValidNotificationCreation() {
        return isOwner(request.resource.data.userId) || isAdmin();
      }

      function isValidNotificationData() {
        let data = request.resource.data;
        return data.keys().hasAll(['userId', 'title', 'message', 'type', 'status', 'createdAt']) &&
               isValidString(data.userId, 1, 100) &&
               isValidString(data.title, 1, 200) &&
               isValidString(data.message, 1, 1000) &&
               data.type in ['job_application', 'booking_confirmed', 'booking_completed', 'payment_received', 'message_received', 'system', 'review_received'] &&
               data.status in ['unread', 'read'] &&
               isValidTimestamp(data.createdAt) &&
               data.createdAt == request.time &&
               (!('actionUrl' in data) || isValidString(data.actionUrl, 0, 500)) &&
               (!('metadata' in data) || data.metadata is map);
      }

      function isValidNotificationUpdate() {
        let data = request.resource.data;
        let existingData = resource.data;
        return data.keys().hasAll(['userId', 'title', 'message', 'type', 'status', 'createdAt', 'updatedAt']) &&
               data.userId == existingData.userId &&
               data.title == existingData.title &&
               data.message == existingData.message &&
               data.type == existingData.type &&
               data.status in ['unread', 'read'] &&
               data.createdAt == existingData.createdAt &&
               isValidTimestamp(data.updatedAt) &&
               data.updatedAt == request.time;
      }
    }

    // --- File Uploads Collection ---
    match /uploads/{uploadId} {
      allow read: if canAccessUpload();
      allow create: if isAuthenticated() && isValidUploadData();
      allow update: if isOwner(resource.data.uploaderId) && isValidUploadUpdate();
      allow delete: if isOwner(resource.data.uploaderId) || isAdmin();

      function canAccessUpload() {
        return isAuthenticated() &&
               (isOwner(resource.data.uploaderId) || 
                ('isPublic' in resource.data && resource.data.isPublic == true) ||
                isAdmin());
      }

      function isValidUploadData() {
        let data = request.resource.data;
        return data.keys().hasAll(['uploaderId', 'fileName', 'fileSize', 'mimeType', 'url', 'createdAt']) &&
               data.uploaderId == request.auth.uid &&
               isValidString(data.fileName, 1, 255) &&
               data.fileSize is number &&
               data.fileSize > 0 &&
               data.fileSize <= 10485760 && // 10MB max
               isValidString(data.mimeType, 1, 100) &&
               isValidString(data.url, 1, 1000) &&
               isValidTimestamp(data.createdAt) &&
               data.createdAt == request.time &&
               (!('isPublic' in data) || data.isPublic is bool) &&
               (!('category' in data) || data.category in ['profile', 'document', 'chat', 'job']);
      }

      function isValidUploadUpdate() {
        let data = request.resource.data;
        let existingData = resource.data;
        return data.keys().hasAll(['uploaderId', 'fileName', 'fileSize', 'mimeType', 'url', 'createdAt', 'updatedAt']) &&
               data.uploaderId == existingData.uploaderId &&
               data.fileName == existingData.fileName &&
               data.fileSize == existingData.fileSize &&
               data.mimeType == existingData.mimeType &&
               data.url == existingData.url &&
               data.createdAt == existingData.createdAt &&
               isValidTimestamp(data.updatedAt) &&
               data.updatedAt == request.time;
      }
    }

    // --- System Collections (Admin Only) ---

    // Analytics Collection
    match /analytics/{document=**} {
      allow read, write: if isAdmin();
    }

    // System Configuration
    match /config/{document=**} {
      allow read: if isAuthenticated();
      allow write: if isAdmin();
    }

    // Audit Logs (Server-side only)
    match /audit_logs/{document=**} {
      allow read: if isAdmin();
      allow write: if false; // Only server-side writes
    }

    // App Metadata
    match /metadata/{document=**} {
      allow read: if isAuthenticated();
      allow write: if isAdmin();
    }

    // Service Categories and Locations (Read-only for users)
    match /service_categories/{document=**} {
      allow read: if isAuthenticated();
      allow write: if isAdmin();
    }

    match /locations/{document=**} {
      allow read: if isAuthenticated();
      allow write: if isAdmin();
    }

    // Reports Collection
    match /reports/{reportId} {
      allow read: if isAdmin() || isOwner(resource.data.reporterId);
      allow create: if isAuthenticated() && isValidReportData();
      allow update: if isAdmin();
      allow delete: if isAdmin();

      function isValidReportData() {
        let data = request.resource.data;
        return data.keys().hasAll(['reporterId', 'reportedId', 'category', 'description', 'status', 'createdAt']) &&
               data.reporterId == request.auth.uid &&
               isValidString(data.reportedId, 1, 100) &&
               data.category in ['inappropriate_behavior', 'fraud', 'poor_service', 'spam', 'other'] &&
               isValidString(data.description, 10, 2000) &&
               data.status == 'pending' &&
               isValidTimestamp(data.createdAt) &&
               data.createdAt == request.time;
      }
    }

    // Default deny rule for any unmatched paths
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
